<?php
/**
 * CreateLdapServerXo
 *
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Nexus Repository Manager REST API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 3.26.1-02
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.15
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Model;

use \ArrayAccess;
use \Swagger\Client\ObjectSerializer;

/**
 * CreateLdapServerXo Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class CreateLdapServerXo implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'CreateLdapServerXo';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'name' => 'string',
        'protocol' => 'string',
        'use_trust_store' => 'bool',
        'host' => 'string',
        'port' => 'int',
        'search_base' => 'string',
        'auth_scheme' => 'string',
        'auth_realm' => 'string',
        'auth_username' => 'string',
        'connection_timeout_seconds' => 'int',
        'connection_retry_delay_seconds' => 'int',
        'max_incidents_count' => 'int',
        'user_base_dn' => 'string',
        'user_subtree' => 'bool',
        'user_object_class' => 'string',
        'user_ldap_filter' => 'string',
        'user_id_attribute' => 'string',
        'user_real_name_attribute' => 'string',
        'user_email_address_attribute' => 'string',
        'user_password_attribute' => 'string',
        'ldap_groups_as_roles' => 'bool',
        'group_type' => 'string',
        'group_base_dn' => 'string',
        'group_subtree' => 'bool',
        'group_object_class' => 'string',
        'group_id_attribute' => 'string',
        'group_member_attribute' => 'string',
        'group_member_format' => 'string',
        'user_member_of_attribute' => 'string',
        'auth_password' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'name' => null,
        'protocol' => null,
        'use_trust_store' => null,
        'host' => null,
        'port' => 'int32',
        'search_base' => null,
        'auth_scheme' => null,
        'auth_realm' => null,
        'auth_username' => null,
        'connection_timeout_seconds' => 'int32',
        'connection_retry_delay_seconds' => 'int32',
        'max_incidents_count' => 'int32',
        'user_base_dn' => null,
        'user_subtree' => null,
        'user_object_class' => null,
        'user_ldap_filter' => null,
        'user_id_attribute' => null,
        'user_real_name_attribute' => null,
        'user_email_address_attribute' => null,
        'user_password_attribute' => null,
        'ldap_groups_as_roles' => null,
        'group_type' => null,
        'group_base_dn' => null,
        'group_subtree' => null,
        'group_object_class' => null,
        'group_id_attribute' => null,
        'group_member_attribute' => null,
        'group_member_format' => null,
        'user_member_of_attribute' => null,
        'auth_password' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'name' => 'name',
        'protocol' => 'protocol',
        'use_trust_store' => 'useTrustStore',
        'host' => 'host',
        'port' => 'port',
        'search_base' => 'searchBase',
        'auth_scheme' => 'authScheme',
        'auth_realm' => 'authRealm',
        'auth_username' => 'authUsername',
        'connection_timeout_seconds' => 'connectionTimeoutSeconds',
        'connection_retry_delay_seconds' => 'connectionRetryDelaySeconds',
        'max_incidents_count' => 'maxIncidentsCount',
        'user_base_dn' => 'userBaseDn',
        'user_subtree' => 'userSubtree',
        'user_object_class' => 'userObjectClass',
        'user_ldap_filter' => 'userLdapFilter',
        'user_id_attribute' => 'userIdAttribute',
        'user_real_name_attribute' => 'userRealNameAttribute',
        'user_email_address_attribute' => 'userEmailAddressAttribute',
        'user_password_attribute' => 'userPasswordAttribute',
        'ldap_groups_as_roles' => 'ldapGroupsAsRoles',
        'group_type' => 'groupType',
        'group_base_dn' => 'groupBaseDn',
        'group_subtree' => 'groupSubtree',
        'group_object_class' => 'groupObjectClass',
        'group_id_attribute' => 'groupIdAttribute',
        'group_member_attribute' => 'groupMemberAttribute',
        'group_member_format' => 'groupMemberFormat',
        'user_member_of_attribute' => 'userMemberOfAttribute',
        'auth_password' => 'authPassword'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'name' => 'setName',
        'protocol' => 'setProtocol',
        'use_trust_store' => 'setUseTrustStore',
        'host' => 'setHost',
        'port' => 'setPort',
        'search_base' => 'setSearchBase',
        'auth_scheme' => 'setAuthScheme',
        'auth_realm' => 'setAuthRealm',
        'auth_username' => 'setAuthUsername',
        'connection_timeout_seconds' => 'setConnectionTimeoutSeconds',
        'connection_retry_delay_seconds' => 'setConnectionRetryDelaySeconds',
        'max_incidents_count' => 'setMaxIncidentsCount',
        'user_base_dn' => 'setUserBaseDn',
        'user_subtree' => 'setUserSubtree',
        'user_object_class' => 'setUserObjectClass',
        'user_ldap_filter' => 'setUserLdapFilter',
        'user_id_attribute' => 'setUserIdAttribute',
        'user_real_name_attribute' => 'setUserRealNameAttribute',
        'user_email_address_attribute' => 'setUserEmailAddressAttribute',
        'user_password_attribute' => 'setUserPasswordAttribute',
        'ldap_groups_as_roles' => 'setLdapGroupsAsRoles',
        'group_type' => 'setGroupType',
        'group_base_dn' => 'setGroupBaseDn',
        'group_subtree' => 'setGroupSubtree',
        'group_object_class' => 'setGroupObjectClass',
        'group_id_attribute' => 'setGroupIdAttribute',
        'group_member_attribute' => 'setGroupMemberAttribute',
        'group_member_format' => 'setGroupMemberFormat',
        'user_member_of_attribute' => 'setUserMemberOfAttribute',
        'auth_password' => 'setAuthPassword'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'name' => 'getName',
        'protocol' => 'getProtocol',
        'use_trust_store' => 'getUseTrustStore',
        'host' => 'getHost',
        'port' => 'getPort',
        'search_base' => 'getSearchBase',
        'auth_scheme' => 'getAuthScheme',
        'auth_realm' => 'getAuthRealm',
        'auth_username' => 'getAuthUsername',
        'connection_timeout_seconds' => 'getConnectionTimeoutSeconds',
        'connection_retry_delay_seconds' => 'getConnectionRetryDelaySeconds',
        'max_incidents_count' => 'getMaxIncidentsCount',
        'user_base_dn' => 'getUserBaseDn',
        'user_subtree' => 'getUserSubtree',
        'user_object_class' => 'getUserObjectClass',
        'user_ldap_filter' => 'getUserLdapFilter',
        'user_id_attribute' => 'getUserIdAttribute',
        'user_real_name_attribute' => 'getUserRealNameAttribute',
        'user_email_address_attribute' => 'getUserEmailAddressAttribute',
        'user_password_attribute' => 'getUserPasswordAttribute',
        'ldap_groups_as_roles' => 'getLdapGroupsAsRoles',
        'group_type' => 'getGroupType',
        'group_base_dn' => 'getGroupBaseDn',
        'group_subtree' => 'getGroupSubtree',
        'group_object_class' => 'getGroupObjectClass',
        'group_id_attribute' => 'getGroupIdAttribute',
        'group_member_attribute' => 'getGroupMemberAttribute',
        'group_member_format' => 'getGroupMemberFormat',
        'user_member_of_attribute' => 'getUserMemberOfAttribute',
        'auth_password' => 'getAuthPassword'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const PROTOCOL_LDAP = 'ldap';
    const PROTOCOL_LDAPS = 'ldaps';
    const AUTH_SCHEME_NONE = 'NONE';
    const AUTH_SCHEME_SIMPLE = 'SIMPLE';
    const AUTH_SCHEME_DIGEST_MD5 = 'DIGEST_MD5';
    const AUTH_SCHEME_CRAM_MD5 = 'CRAM_MD5';
    const GROUP_TYPE__STATIC = 'static';
    const GROUP_TYPE_DYNAMIC = 'dynamic';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getProtocolAllowableValues()
    {
        return [
            self::PROTOCOL_LDAP,
            self::PROTOCOL_LDAPS,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getAuthSchemeAllowableValues()
    {
        return [
            self::AUTH_SCHEME_NONE,
            self::AUTH_SCHEME_SIMPLE,
            self::AUTH_SCHEME_DIGEST_MD5,
            self::AUTH_SCHEME_CRAM_MD5,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getGroupTypeAllowableValues()
    {
        return [
            self::GROUP_TYPE__STATIC,
            self::GROUP_TYPE_DYNAMIC,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['name'] = isset($data['name']) ? $data['name'] : null;
        $this->container['protocol'] = isset($data['protocol']) ? $data['protocol'] : null;
        $this->container['use_trust_store'] = isset($data['use_trust_store']) ? $data['use_trust_store'] : null;
        $this->container['host'] = isset($data['host']) ? $data['host'] : null;
        $this->container['port'] = isset($data['port']) ? $data['port'] : null;
        $this->container['search_base'] = isset($data['search_base']) ? $data['search_base'] : null;
        $this->container['auth_scheme'] = isset($data['auth_scheme']) ? $data['auth_scheme'] : null;
        $this->container['auth_realm'] = isset($data['auth_realm']) ? $data['auth_realm'] : null;
        $this->container['auth_username'] = isset($data['auth_username']) ? $data['auth_username'] : null;
        $this->container['connection_timeout_seconds'] = isset($data['connection_timeout_seconds']) ? $data['connection_timeout_seconds'] : null;
        $this->container['connection_retry_delay_seconds'] = isset($data['connection_retry_delay_seconds']) ? $data['connection_retry_delay_seconds'] : null;
        $this->container['max_incidents_count'] = isset($data['max_incidents_count']) ? $data['max_incidents_count'] : null;
        $this->container['user_base_dn'] = isset($data['user_base_dn']) ? $data['user_base_dn'] : null;
        $this->container['user_subtree'] = isset($data['user_subtree']) ? $data['user_subtree'] : null;
        $this->container['user_object_class'] = isset($data['user_object_class']) ? $data['user_object_class'] : null;
        $this->container['user_ldap_filter'] = isset($data['user_ldap_filter']) ? $data['user_ldap_filter'] : null;
        $this->container['user_id_attribute'] = isset($data['user_id_attribute']) ? $data['user_id_attribute'] : null;
        $this->container['user_real_name_attribute'] = isset($data['user_real_name_attribute']) ? $data['user_real_name_attribute'] : null;
        $this->container['user_email_address_attribute'] = isset($data['user_email_address_attribute']) ? $data['user_email_address_attribute'] : null;
        $this->container['user_password_attribute'] = isset($data['user_password_attribute']) ? $data['user_password_attribute'] : null;
        $this->container['ldap_groups_as_roles'] = isset($data['ldap_groups_as_roles']) ? $data['ldap_groups_as_roles'] : null;
        $this->container['group_type'] = isset($data['group_type']) ? $data['group_type'] : null;
        $this->container['group_base_dn'] = isset($data['group_base_dn']) ? $data['group_base_dn'] : null;
        $this->container['group_subtree'] = isset($data['group_subtree']) ? $data['group_subtree'] : null;
        $this->container['group_object_class'] = isset($data['group_object_class']) ? $data['group_object_class'] : null;
        $this->container['group_id_attribute'] = isset($data['group_id_attribute']) ? $data['group_id_attribute'] : null;
        $this->container['group_member_attribute'] = isset($data['group_member_attribute']) ? $data['group_member_attribute'] : null;
        $this->container['group_member_format'] = isset($data['group_member_format']) ? $data['group_member_format'] : null;
        $this->container['user_member_of_attribute'] = isset($data['user_member_of_attribute']) ? $data['user_member_of_attribute'] : null;
        $this->container['auth_password'] = isset($data['auth_password']) ? $data['auth_password'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['name'] === null) {
            $invalidProperties[] = "'name' can't be null";
        }
        if ($this->container['protocol'] === null) {
            $invalidProperties[] = "'protocol' can't be null";
        }
        $allowedValues = $this->getProtocolAllowableValues();
        if (!is_null($this->container['protocol']) && !in_array($this->container['protocol'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'protocol', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['host'] === null) {
            $invalidProperties[] = "'host' can't be null";
        }
        if ($this->container['port'] === null) {
            $invalidProperties[] = "'port' can't be null";
        }
        if ($this->container['search_base'] === null) {
            $invalidProperties[] = "'search_base' can't be null";
        }
        if ($this->container['auth_scheme'] === null) {
            $invalidProperties[] = "'auth_scheme' can't be null";
        }
        $allowedValues = $this->getAuthSchemeAllowableValues();
        if (!is_null($this->container['auth_scheme']) && !in_array($this->container['auth_scheme'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'auth_scheme', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['connection_timeout_seconds'] === null) {
            $invalidProperties[] = "'connection_timeout_seconds' can't be null";
        }
        if (($this->container['connection_timeout_seconds'] > 3600)) {
            $invalidProperties[] = "invalid value for 'connection_timeout_seconds', must be smaller than or equal to 3600.";
        }

        if (($this->container['connection_timeout_seconds'] < 1)) {
            $invalidProperties[] = "invalid value for 'connection_timeout_seconds', must be bigger than or equal to 1.";
        }

        if ($this->container['connection_retry_delay_seconds'] === null) {
            $invalidProperties[] = "'connection_retry_delay_seconds' can't be null";
        }
        if (($this->container['connection_retry_delay_seconds'] < 0)) {
            $invalidProperties[] = "invalid value for 'connection_retry_delay_seconds', must be bigger than or equal to 0.";
        }

        if ($this->container['max_incidents_count'] === null) {
            $invalidProperties[] = "'max_incidents_count' can't be null";
        }
        if (($this->container['max_incidents_count'] < 0)) {
            $invalidProperties[] = "invalid value for 'max_incidents_count', must be bigger than or equal to 0.";
        }

        if ($this->container['group_type'] === null) {
            $invalidProperties[] = "'group_type' can't be null";
        }
        $allowedValues = $this->getGroupTypeAllowableValues();
        if (!is_null($this->container['group_type']) && !in_array($this->container['group_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'group_type', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['group_object_class']) && (mb_strlen($this->container['group_object_class']) > 0)) {
            $invalidProperties[] = "invalid value for 'group_object_class', the character length must be smaller than or equal to 0.";
        }

        if (!is_null($this->container['group_object_class']) && (mb_strlen($this->container['group_object_class']) < 0)) {
            $invalidProperties[] = "invalid value for 'group_object_class', the character length must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['group_id_attribute']) && (mb_strlen($this->container['group_id_attribute']) > 0)) {
            $invalidProperties[] = "invalid value for 'group_id_attribute', the character length must be smaller than or equal to 0.";
        }

        if (!is_null($this->container['group_id_attribute']) && (mb_strlen($this->container['group_id_attribute']) < 0)) {
            $invalidProperties[] = "invalid value for 'group_id_attribute', the character length must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['group_member_attribute']) && (mb_strlen($this->container['group_member_attribute']) > 0)) {
            $invalidProperties[] = "invalid value for 'group_member_attribute', the character length must be smaller than or equal to 0.";
        }

        if (!is_null($this->container['group_member_attribute']) && (mb_strlen($this->container['group_member_attribute']) < 0)) {
            $invalidProperties[] = "invalid value for 'group_member_attribute', the character length must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['group_member_format']) && (mb_strlen($this->container['group_member_format']) > 0)) {
            $invalidProperties[] = "invalid value for 'group_member_format', the character length must be smaller than or equal to 0.";
        }

        if (!is_null($this->container['group_member_format']) && (mb_strlen($this->container['group_member_format']) < 0)) {
            $invalidProperties[] = "invalid value for 'group_member_format', the character length must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['user_member_of_attribute']) && (mb_strlen($this->container['user_member_of_attribute']) > 0)) {
            $invalidProperties[] = "invalid value for 'user_member_of_attribute', the character length must be smaller than or equal to 0.";
        }

        if (!is_null($this->container['user_member_of_attribute']) && (mb_strlen($this->container['user_member_of_attribute']) < 0)) {
            $invalidProperties[] = "invalid value for 'user_member_of_attribute', the character length must be bigger than or equal to 0.";
        }

        if ($this->container['auth_password'] === null) {
            $invalidProperties[] = "'auth_password' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets name
     *
     * @return string
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string $name LDAP server name
     *
     * @return $this
     */
    public function setName($name)
    {
        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets protocol
     *
     * @return string
     */
    public function getProtocol()
    {
        return $this->container['protocol'];
    }

    /**
     * Sets protocol
     *
     * @param string $protocol LDAP server connection Protocol to use
     *
     * @return $this
     */
    public function setProtocol($protocol)
    {
        $allowedValues = $this->getProtocolAllowableValues();
        if (!in_array($protocol, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'protocol', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['protocol'] = $protocol;

        return $this;
    }

    /**
     * Gets use_trust_store
     *
     * @return bool
     */
    public function getUseTrustStore()
    {
        return $this->container['use_trust_store'];
    }

    /**
     * Sets use_trust_store
     *
     * @param bool $use_trust_store Whether to use certificates stored in Nexus Repository Manager's truststore
     *
     * @return $this
     */
    public function setUseTrustStore($use_trust_store)
    {
        $this->container['use_trust_store'] = $use_trust_store;

        return $this;
    }

    /**
     * Gets host
     *
     * @return string
     */
    public function getHost()
    {
        return $this->container['host'];
    }

    /**
     * Sets host
     *
     * @param string $host LDAP server connection hostname
     *
     * @return $this
     */
    public function setHost($host)
    {
        $this->container['host'] = $host;

        return $this;
    }

    /**
     * Gets port
     *
     * @return int
     */
    public function getPort()
    {
        return $this->container['port'];
    }

    /**
     * Sets port
     *
     * @param int $port LDAP server connection port to use
     *
     * @return $this
     */
    public function setPort($port)
    {
        $this->container['port'] = $port;

        return $this;
    }

    /**
     * Gets search_base
     *
     * @return string
     */
    public function getSearchBase()
    {
        return $this->container['search_base'];
    }

    /**
     * Sets search_base
     *
     * @param string $search_base LDAP location to be added to the connection URL
     *
     * @return $this
     */
    public function setSearchBase($search_base)
    {
        $this->container['search_base'] = $search_base;

        return $this;
    }

    /**
     * Gets auth_scheme
     *
     * @return string
     */
    public function getAuthScheme()
    {
        return $this->container['auth_scheme'];
    }

    /**
     * Sets auth_scheme
     *
     * @param string $auth_scheme Authentication scheme used for connecting to LDAP server
     *
     * @return $this
     */
    public function setAuthScheme($auth_scheme)
    {
        $allowedValues = $this->getAuthSchemeAllowableValues();
        if (!in_array($auth_scheme, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'auth_scheme', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['auth_scheme'] = $auth_scheme;

        return $this;
    }

    /**
     * Gets auth_realm
     *
     * @return string
     */
    public function getAuthRealm()
    {
        return $this->container['auth_realm'];
    }

    /**
     * Sets auth_realm
     *
     * @param string $auth_realm The SASL realm to bind to. Required if authScheme is CRAM_MD5 or DIGEST_MD5
     *
     * @return $this
     */
    public function setAuthRealm($auth_realm)
    {
        $this->container['auth_realm'] = $auth_realm;

        return $this;
    }

    /**
     * Gets auth_username
     *
     * @return string
     */
    public function getAuthUsername()
    {
        return $this->container['auth_username'];
    }

    /**
     * Sets auth_username
     *
     * @param string $auth_username This must be a fully qualified username if simple authentication is used. Required if authScheme other than none.
     *
     * @return $this
     */
    public function setAuthUsername($auth_username)
    {
        $this->container['auth_username'] = $auth_username;

        return $this;
    }

    /**
     * Gets connection_timeout_seconds
     *
     * @return int
     */
    public function getConnectionTimeoutSeconds()
    {
        return $this->container['connection_timeout_seconds'];
    }

    /**
     * Sets connection_timeout_seconds
     *
     * @param int $connection_timeout_seconds How long to wait before timeout
     *
     * @return $this
     */
    public function setConnectionTimeoutSeconds($connection_timeout_seconds)
    {

        if (($connection_timeout_seconds > 3600)) {
            throw new \InvalidArgumentException('invalid value for $connection_timeout_seconds when calling CreateLdapServerXo., must be smaller than or equal to 3600.');
        }
        if (($connection_timeout_seconds < 1)) {
            throw new \InvalidArgumentException('invalid value for $connection_timeout_seconds when calling CreateLdapServerXo., must be bigger than or equal to 1.');
        }

        $this->container['connection_timeout_seconds'] = $connection_timeout_seconds;

        return $this;
    }

    /**
     * Gets connection_retry_delay_seconds
     *
     * @return int
     */
    public function getConnectionRetryDelaySeconds()
    {
        return $this->container['connection_retry_delay_seconds'];
    }

    /**
     * Sets connection_retry_delay_seconds
     *
     * @param int $connection_retry_delay_seconds How long to wait before retrying
     *
     * @return $this
     */
    public function setConnectionRetryDelaySeconds($connection_retry_delay_seconds)
    {

        if (($connection_retry_delay_seconds < 0)) {
            throw new \InvalidArgumentException('invalid value for $connection_retry_delay_seconds when calling CreateLdapServerXo., must be bigger than or equal to 0.');
        }

        $this->container['connection_retry_delay_seconds'] = $connection_retry_delay_seconds;

        return $this;
    }

    /**
     * Gets max_incidents_count
     *
     * @return int
     */
    public function getMaxIncidentsCount()
    {
        return $this->container['max_incidents_count'];
    }

    /**
     * Sets max_incidents_count
     *
     * @param int $max_incidents_count How many retry attempts
     *
     * @return $this
     */
    public function setMaxIncidentsCount($max_incidents_count)
    {

        if (($max_incidents_count < 0)) {
            throw new \InvalidArgumentException('invalid value for $max_incidents_count when calling CreateLdapServerXo., must be bigger than or equal to 0.');
        }

        $this->container['max_incidents_count'] = $max_incidents_count;

        return $this;
    }

    /**
     * Gets user_base_dn
     *
     * @return string
     */
    public function getUserBaseDn()
    {
        return $this->container['user_base_dn'];
    }

    /**
     * Sets user_base_dn
     *
     * @param string $user_base_dn The relative DN where user objects are found (e.g. ou=people). This value will have the Search base DN value appended to form the full User search base DN.
     *
     * @return $this
     */
    public function setUserBaseDn($user_base_dn)
    {
        $this->container['user_base_dn'] = $user_base_dn;

        return $this;
    }

    /**
     * Gets user_subtree
     *
     * @return bool
     */
    public function getUserSubtree()
    {
        return $this->container['user_subtree'];
    }

    /**
     * Sets user_subtree
     *
     * @param bool $user_subtree Are users located in structures below the user base DN?
     *
     * @return $this
     */
    public function setUserSubtree($user_subtree)
    {
        $this->container['user_subtree'] = $user_subtree;

        return $this;
    }

    /**
     * Gets user_object_class
     *
     * @return string
     */
    public function getUserObjectClass()
    {
        return $this->container['user_object_class'];
    }

    /**
     * Sets user_object_class
     *
     * @param string $user_object_class LDAP class for user objects
     *
     * @return $this
     */
    public function setUserObjectClass($user_object_class)
    {
        $this->container['user_object_class'] = $user_object_class;

        return $this;
    }

    /**
     * Gets user_ldap_filter
     *
     * @return string
     */
    public function getUserLdapFilter()
    {
        return $this->container['user_ldap_filter'];
    }

    /**
     * Sets user_ldap_filter
     *
     * @param string $user_ldap_filter LDAP search filter to limit user search
     *
     * @return $this
     */
    public function setUserLdapFilter($user_ldap_filter)
    {
        $this->container['user_ldap_filter'] = $user_ldap_filter;

        return $this;
    }

    /**
     * Gets user_id_attribute
     *
     * @return string
     */
    public function getUserIdAttribute()
    {
        return $this->container['user_id_attribute'];
    }

    /**
     * Sets user_id_attribute
     *
     * @param string $user_id_attribute This is used to find a user given its user ID
     *
     * @return $this
     */
    public function setUserIdAttribute($user_id_attribute)
    {
        $this->container['user_id_attribute'] = $user_id_attribute;

        return $this;
    }

    /**
     * Gets user_real_name_attribute
     *
     * @return string
     */
    public function getUserRealNameAttribute()
    {
        return $this->container['user_real_name_attribute'];
    }

    /**
     * Sets user_real_name_attribute
     *
     * @param string $user_real_name_attribute This is used to find a real name given the user ID
     *
     * @return $this
     */
    public function setUserRealNameAttribute($user_real_name_attribute)
    {
        $this->container['user_real_name_attribute'] = $user_real_name_attribute;

        return $this;
    }

    /**
     * Gets user_email_address_attribute
     *
     * @return string
     */
    public function getUserEmailAddressAttribute()
    {
        return $this->container['user_email_address_attribute'];
    }

    /**
     * Sets user_email_address_attribute
     *
     * @param string $user_email_address_attribute This is used to find an email address given the user ID
     *
     * @return $this
     */
    public function setUserEmailAddressAttribute($user_email_address_attribute)
    {
        $this->container['user_email_address_attribute'] = $user_email_address_attribute;

        return $this;
    }

    /**
     * Gets user_password_attribute
     *
     * @return string
     */
    public function getUserPasswordAttribute()
    {
        return $this->container['user_password_attribute'];
    }

    /**
     * Sets user_password_attribute
     *
     * @param string $user_password_attribute If this field is blank the user will be authenticated against a bind with the LDAP server
     *
     * @return $this
     */
    public function setUserPasswordAttribute($user_password_attribute)
    {
        $this->container['user_password_attribute'] = $user_password_attribute;

        return $this;
    }

    /**
     * Gets ldap_groups_as_roles
     *
     * @return bool
     */
    public function getLdapGroupsAsRoles()
    {
        return $this->container['ldap_groups_as_roles'];
    }

    /**
     * Sets ldap_groups_as_roles
     *
     * @param bool $ldap_groups_as_roles Denotes whether LDAP assigned roles are used as Nexus Repository Manager roles
     *
     * @return $this
     */
    public function setLdapGroupsAsRoles($ldap_groups_as_roles)
    {
        $this->container['ldap_groups_as_roles'] = $ldap_groups_as_roles;

        return $this;
    }

    /**
     * Gets group_type
     *
     * @return string
     */
    public function getGroupType()
    {
        return $this->container['group_type'];
    }

    /**
     * Sets group_type
     *
     * @param string $group_type Defines a type of groups used: static (a group contains a list of users) or dynamic (a user contains a list of groups). Required if ldapGroupsAsRoles is true.
     *
     * @return $this
     */
    public function setGroupType($group_type)
    {
        $allowedValues = $this->getGroupTypeAllowableValues();
        if (!in_array($group_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'group_type', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['group_type'] = $group_type;

        return $this;
    }

    /**
     * Gets group_base_dn
     *
     * @return string
     */
    public function getGroupBaseDn()
    {
        return $this->container['group_base_dn'];
    }

    /**
     * Sets group_base_dn
     *
     * @param string $group_base_dn The relative DN where group objects are found (e.g. ou=Group). This value will have the Search base DN value appended to form the full Group search base DN.
     *
     * @return $this
     */
    public function setGroupBaseDn($group_base_dn)
    {
        $this->container['group_base_dn'] = $group_base_dn;

        return $this;
    }

    /**
     * Gets group_subtree
     *
     * @return bool
     */
    public function getGroupSubtree()
    {
        return $this->container['group_subtree'];
    }

    /**
     * Sets group_subtree
     *
     * @param bool $group_subtree Are groups located in structures below the group base DN
     *
     * @return $this
     */
    public function setGroupSubtree($group_subtree)
    {
        $this->container['group_subtree'] = $group_subtree;

        return $this;
    }

    /**
     * Gets group_object_class
     *
     * @return string
     */
    public function getGroupObjectClass()
    {
        return $this->container['group_object_class'];
    }

    /**
     * Sets group_object_class
     *
     * @param string $group_object_class LDAP class for group objects. Required if groupType is static
     *
     * @return $this
     */
    public function setGroupObjectClass($group_object_class)
    {
        if (!is_null($group_object_class) && (mb_strlen($group_object_class) > 0)) {
            throw new \InvalidArgumentException('invalid length for $group_object_class when calling CreateLdapServerXo., must be smaller than or equal to 0.');
        }
        if (!is_null($group_object_class) && (mb_strlen($group_object_class) < 0)) {
            throw new \InvalidArgumentException('invalid length for $group_object_class when calling CreateLdapServerXo., must be bigger than or equal to 0.');
        }

        $this->container['group_object_class'] = $group_object_class;

        return $this;
    }

    /**
     * Gets group_id_attribute
     *
     * @return string
     */
    public function getGroupIdAttribute()
    {
        return $this->container['group_id_attribute'];
    }

    /**
     * Sets group_id_attribute
     *
     * @param string $group_id_attribute This field specifies the attribute of the Object class that defines the Group ID. Required if groupType is static
     *
     * @return $this
     */
    public function setGroupIdAttribute($group_id_attribute)
    {
        if (!is_null($group_id_attribute) && (mb_strlen($group_id_attribute) > 0)) {
            throw new \InvalidArgumentException('invalid length for $group_id_attribute when calling CreateLdapServerXo., must be smaller than or equal to 0.');
        }
        if (!is_null($group_id_attribute) && (mb_strlen($group_id_attribute) < 0)) {
            throw new \InvalidArgumentException('invalid length for $group_id_attribute when calling CreateLdapServerXo., must be bigger than or equal to 0.');
        }

        $this->container['group_id_attribute'] = $group_id_attribute;

        return $this;
    }

    /**
     * Gets group_member_attribute
     *
     * @return string
     */
    public function getGroupMemberAttribute()
    {
        return $this->container['group_member_attribute'];
    }

    /**
     * Sets group_member_attribute
     *
     * @param string $group_member_attribute LDAP attribute containing the usernames for the group. Required if groupType is static
     *
     * @return $this
     */
    public function setGroupMemberAttribute($group_member_attribute)
    {
        if (!is_null($group_member_attribute) && (mb_strlen($group_member_attribute) > 0)) {
            throw new \InvalidArgumentException('invalid length for $group_member_attribute when calling CreateLdapServerXo., must be smaller than or equal to 0.');
        }
        if (!is_null($group_member_attribute) && (mb_strlen($group_member_attribute) < 0)) {
            throw new \InvalidArgumentException('invalid length for $group_member_attribute when calling CreateLdapServerXo., must be bigger than or equal to 0.');
        }

        $this->container['group_member_attribute'] = $group_member_attribute;

        return $this;
    }

    /**
     * Gets group_member_format
     *
     * @return string
     */
    public function getGroupMemberFormat()
    {
        return $this->container['group_member_format'];
    }

    /**
     * Sets group_member_format
     *
     * @param string $group_member_format The format of user ID stored in the group member attribute. Required if groupType is static
     *
     * @return $this
     */
    public function setGroupMemberFormat($group_member_format)
    {
        if (!is_null($group_member_format) && (mb_strlen($group_member_format) > 0)) {
            throw new \InvalidArgumentException('invalid length for $group_member_format when calling CreateLdapServerXo., must be smaller than or equal to 0.');
        }
        if (!is_null($group_member_format) && (mb_strlen($group_member_format) < 0)) {
            throw new \InvalidArgumentException('invalid length for $group_member_format when calling CreateLdapServerXo., must be bigger than or equal to 0.');
        }

        $this->container['group_member_format'] = $group_member_format;

        return $this;
    }

    /**
     * Gets user_member_of_attribute
     *
     * @return string
     */
    public function getUserMemberOfAttribute()
    {
        return $this->container['user_member_of_attribute'];
    }

    /**
     * Sets user_member_of_attribute
     *
     * @param string $user_member_of_attribute Set this to the attribute used to store the attribute which holds groups DN in the user object. Required if groupType is dynamic
     *
     * @return $this
     */
    public function setUserMemberOfAttribute($user_member_of_attribute)
    {
        if (!is_null($user_member_of_attribute) && (mb_strlen($user_member_of_attribute) > 0)) {
            throw new \InvalidArgumentException('invalid length for $user_member_of_attribute when calling CreateLdapServerXo., must be smaller than or equal to 0.');
        }
        if (!is_null($user_member_of_attribute) && (mb_strlen($user_member_of_attribute) < 0)) {
            throw new \InvalidArgumentException('invalid length for $user_member_of_attribute when calling CreateLdapServerXo., must be bigger than or equal to 0.');
        }

        $this->container['user_member_of_attribute'] = $user_member_of_attribute;

        return $this;
    }

    /**
     * Gets auth_password
     *
     * @return string
     */
    public function getAuthPassword()
    {
        return $this->container['auth_password'];
    }

    /**
     * Sets auth_password
     *
     * @param string $auth_password The password to bind with. Required if authScheme other than none.
     *
     * @return $this
     */
    public function setAuthPassword($auth_password)
    {
        $this->container['auth_password'] = $auth_password;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


